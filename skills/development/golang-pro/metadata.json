{
  "name": "golang-pro",
  "description": "Use when building Go applications requiring concurrent programming, high-performance systems, microservices, or cloud-native architectures where idiomatic patterns, error handling excellence, and efficiency are critical. Specifically:\\\\n\\\\n<example>\\\\nContext: Building a gRPC-based microservice that handles thousands of concurrent requests with strict latency requirements and needs proper error propagation and graceful shutdown\\\\nuser: \\\"Create a gRPC service in Go that can handle 10k concurrent connections with sub-50ms p99 latency. Need proper context propagation for cancellation, comprehensive error handling with wrapped errors, and graceful shutdown that stops accepting new connections but drains existing ones.\\\"\\\\nassistant: \\\"I'll architect a gRPC service with streaming handlers, context-aware deadlines, wrapped error types for detailed error chains, interceptors for logging/metrics, worker pools for bounded concurrency, and a shutdown coordinator using context cancellation. This ensures low-latency responses, proper error tracing, and clean process termination.\\\"\\\\n<commentary>\\\\nInvoke golang-pro when building Go services where concurrency, error handling, and performance optimization are primary concerns—especially gRPC/REST APIs, microservices, and systems requiring context propagation and resource lifecycle management.\\\\n</commentary>\\\\n</example>\\\\n\\\\n<example>\\\\nContext: Optimizing a Go backend's data pipeline processing millions of events daily, with memory pressure and CPU hotspots\\\\nuser: \\\"Our Go event processor is hitting memory limits processing 1M events/day. Need to profile memory allocations, reduce GC pressure with object pooling, and benchmark critical paths. Current implementation does full unmarshaling for every event even when we only need a few fields.\\\"\\\\nassistant: \\\"I'll apply performance optimization techniques: use pprof to identify allocation hotspots, implement sync.Pool for frequent object reuse, benchmark processing pipeline with criterion-style comparisons, apply zero-allocation patterns for hot paths, consider using partial unmarshaling with json.Decoder for selective field extraction, and tune GC with GOGC tuning.\\\"\\\\n<commentary>\\\\nUse golang-pro when performance is a primary requirement—optimizing memory usage, reducing CPU load, implementing benchmarks, profiling code, or building systems where latency and throughput matter significantly.\\\\n</commentary>\\\\n</example>\\\\n\\\\n<example>\\\\nContext: Monorepo with multiple Go services needing shared error handling, logging patterns, and graceful inter-service communication with proper dependency management\\\\nuser: \\\"We have 5 microservices in a monorepo that need consistent error handling, structured logging, and service discovery. How do we organize shared code, manage go.mod dependencies, create reusable interfaces, and ensure all services follow the same patterns without tight coupling?\\\"\\\\nassistant: \\\"I'll structure the monorepo with separate modules for each service plus shared library packages for error types, logging setup, and interfaces. Use go.mod's replace directive for local dependencies, implement functional options pattern for service configuration, define small focused interfaces for service boundaries, and set up table-driven tests that validate all services implement required contracts.\\\"\\\\n<commentary>\\\\nInvoke golang-pro for architectural decisions spanning multiple Go projects, monorepo organization, establishing shared patterns across services, dependency management strategies, or when building frameworks that multiple Go teams will use.\\\\n</commentary>\\\\n</example>",
  "category": "development",
  "canonical_category": "development",
  "repository": "Elpulgo/azdo",
  "repository_url": "https://github.com/Elpulgo/azdo",
  "author": "Elpulgo",
  "author_avatar": "https://github.com/Elpulgo.png",
  "file_path": "Skill.md",
  "source": "github_code_search",
  "stars": 0,
  "quality_score": 45,
  "best_practices_score": 40,
  "skill_level": 2,
  "skill_level_label": "instructions",
  "has_scripts": false,
  "has_extra_files": true,
  "downloads": 0,
  "content_hash": "f44734fedddea3cddf0da2715197474c4fe89a0bfa9239ceb034cae63e49433a",
  "indexed_at": "2026-02-26T05:45:14.848Z",
  "synced_at": "2026-02-28T03:54:55.518Z",
  "omni_registry_url": "https://omni-skill-registry.omniroute.online/#/skill/ae043b8f081b1d8dcf7089df977ea95c40090e11aaf77971b1f738e56ebc4167",
  "install_command": "mkdir -p .claude/skills/golang-pro && curl -sL \"https://raw.githubusercontent.com/Elpulgo/azdo/main/SKILL.md\" > .claude/skills/golang-pro/SKILL.md",
  "raw_url": "https://raw.githubusercontent.com/Elpulgo/azdo/main/SKILL.md"
}
